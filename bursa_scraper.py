# -*- coding: utf-8 -*-
"""Bursa scraper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/tys203831/75c60c26862d53adafe01b7ddd7fda3b/bursa-scraper.ipynb

## Setup
"""
import scripts
import streamlit as st
import requests, yfinance
import time
import re
import threading
from typing import Union, List, Dict, Tuple
import datetime, dateutil
import numpy, pandas, scipy
import logging
from queue import Queue
import json


st.set_page_config(layout="wide")
no_of_threads: int = 300

# sidebar
last_updated = [date for date in open("./data/last_updated.txt", "r")]

if len(last_updated) !=0:
  st.write(f"Last Updated on {last_updated[0]}")
else:
  st.write(f"Haven't updated yet.")

# main page
st.markdown("# Bursa Stock Scraper")

with st.sidebar.form("input form"):
  rf: float = st.number_input(value=4.00, step= 0.05, label="Risk free rate (%): ")# 0.04 # risk free rate
  period: int = st.number_input(value = 5, min_value=0, max_value=10, label="Valid period: 1-10") # 5 # e.g. 5 = 5 years
  interval: str = st.text_input(value = "1wk", label="Valid interval: 1d,1wk,1mo,3mo") #"1wk"
  confidence_level: float = st.number_input(value = 0.05, min_value=0.01, max_value = 0.1, label="Confidence level of linear regression: ")
  include_dividends: bool = False #: bool = st.checkbox(value=False, label="Whether to consider dividend into stock returns when calculating beta?")
  exclude_warrant: bool = st.checkbox(value=True, label="Exclude warrant from Bursa stocks.")
  skipna: bool = False # st.checkbox(value=False, label="Skip NaN values for annualized return & standard deviation.")#False # skip NaN values for annualized return & annualized standard deviation  
  
  submitted = st.form_submit_button("Submit")

if not submitted:
  scripts.set_dataframe.display_data()
  
if submitted:
  st.write("Please kindly wait 30 minutes for the results!")
  ## Retrieve Data & Data Cleaning
  ### (i) Get stock ticker from Bursa
  with st.spinner("Get stock tickers from Bursa..."):
    clean_df_stock_list = scripts.get_data.getStockOverview()
    full_stock_list = scripts.get_data.getStockTicker(clean_df_stock_list)

  if exclude_warrant: 
    full_stock_list = [stock for stock in full_stock_list if not bool(re.match(pattern="\d+[a-zA-Z]+",string=stock))]

  #### -- Get stock price history
  # Step 2: create a function to get stock & index price history from yahoo finance

  def getData(ticker_code: Union[str, list], period:str, interval:str) -> pandas.DataFrame:
    # get stock return dataframe of the Bursa stocks
    if isinstance(ticker_code, list):
      ticker_code = [str(ticker) + ".KL" if not str(ticker).endswith(".KL") and not ticker.startswith("^") else str(ticker) for ticker in ticker_code]
      ticker_code = " ".join(ticker_code)
    elif isinstance(ticker_code, str) and not ticker_code.endswith(".KL") and not ticker_code.startswith("^"): 
      ticker_code = ticker_code + ".KL"
    df_stock = yfinance.download(tickers=ticker_code, period=period, interval=interval, group_by="column")
    df_stock = pandas.DataFrame(df_stock["Adj Close"]).fillna(method="ffill", axis=0)
    return df_stock.reset_index()

  def getReturn(df_stock: pandas.DataFrame) -> pandas.DataFrame:
    df_stock["Date"] = pandas.to_datetime(df_stock["Date"])
    df_stock_return = df_stock.set_index("Date").pct_change()
    return df_stock_return[1:].reset_index()

  def filterDataBasedYear(df, period: int):
    # get stock history of previous n years (e.g. 2 years stock return data out of 5 years)
    n_years_from_today = datetime.date.today() - dateutil.relativedelta.relativedelta(years=+period)
    n_years_from_today = n_years_from_today.strftime("%Y-%m-%d")
    return df[df["Date"]>= n_years_from_today]

  # Step 5: Download stock return dataframe of Bursa Malaysia stocks from yahoo finance using yfinance
  #stock_list = workSheet.col_values(2)[1:]
  with st.spinner("Download stock price history..."):
    stock_df = getData(ticker_code=full_stock_list, period=str(period)+"y", interval=interval)

  #### -- Get dividend history

  # Step 6: Download dividend dataframe of Bursa Malaysia stocks from yahoo finance using yfinance
  multilevel_dict = {}

  def bursa_ticker_amend(ticker_code: Union[list, str]) -> List[str]:
    if isinstance(ticker_code, list):
      ticker_code = [str(ticker) + ".KL" if not str(ticker).endswith(".KL") and not ticker.startswith("^") else str(ticker) for ticker in ticker_code]
    elif isinstance(ticker_code, str) and not ticker_code.endswith(".KL") and not ticker_code.startswith("^"): 
      ticker_code = ticker_code + ".KL"
    return ticker_code

  # scrape dividend history from yahoo finance
  def dividend_scraper(q: Queue) -> Dict[str, Dict[datetime.datetime ,float]]:  
    while not q.empty():
      stock = q.get()
      try:
        ticker = yfinance.Ticker(stock)
        dividends = ticker.get_dividends().to_dict()
        multilevel_dict.update({stock:dividends})   
      except AttributeError:
        print("No data found! No dividends are distributed!")
    return multilevel_dict

  if include_dividends:
    with st.spinner("Get dividend history..."):
      full_bursa_stock_list = bursa_ticker_amend(full_stock_list)

      q = Queue()
      _ = list(map(q.put, full_bursa_stock_list))


        # Create 4 scraper workers
      for idx in range(no_of_threads): # range(0, len(full_stock_list),1):
        t =threading.Thread(target=dividend_scraper,args=(q,))
        t.start()

      q.join()
    
      """#### -- Merge dataframe of stock price & dividend history"""
      dividend_history = pandas.DataFrame.from_dict(multilevel_dict)
      dividend_history = dividend_history.reset_index()
      dividend_history = dividend_history.rename(columns= {"index":"Date"})

      # create a date range series
      datetable = pandas.date_range(start=min(stock_df["Date"]), end = max(stock_df["Date"]), freq="D").to_series(name="Date")

      # merge two dataframes: datetable and dividend_history
      sorted_dividend_history = pandas.merge(datetable, dividend_history, on="Date", how="left")

      new_sorted_dividend_history= sorted_dividend_history.copy(deep=True).reset_index()
      new_sorted_dividend_history["Date"] = pandas.to_datetime(new_sorted_dividend_history["Date"])
      new_sorted_dividend_history = new_sorted_dividend_history.reindex(columns=stock_df.columns).fillna(0)
      # new_sorted_dividend_history

      stock_with_div_df = stock_df.set_index("Date").add(new_sorted_dividend_history.set_index("Date"))
      if interval != "1d":
        resample_period = {"1wk": "W","1mo":"M","3mo": "Q"}
        stock_with_div_df = stock_with_div_df.resample(resample_period[interval]).mean().reset_index()
      else:
        stock_with_div_df = stock_with_div_df.mean().reset_index()
    
  with st.spinner("Calculate stock return..."):   
    if include_dividends:
      """#### -- Get stock return (including dividend)"""
      total_stock_return_df = getReturn(stock_with_div_df)
        
    else:
      total_stock_return_df = getReturn(stock_df)
      # total_stock_return_df

  #### -- Get beta and alpha using Linear Regression

  # Step 3: create function to calculate beta using Linear Regression

  def calc_beta(excess_stock_return:list, excess_index_return:list, confidence_level: float) -> Tuple[float, float, float, float, float, str]:
    beta, intercept, rvalue, pvalue, stderr = scipy.stats.linregress(x=excess_index_return, y=excess_stock_return)
    rsquared = rvalue**2
    normality = normality_test(excess_stock_return, confidence_level) 
    return beta, intercept, rsquared, pvalue, stderr, normality

  def normality_test(excess_stock_return:list, confidence_level:float, nan_policy="propagate") -> Union[bool, str]: 
    # D’Agostino’s K-squared test on excess return data
    try:  
      k2, p = scipy.stats.normaltest(excess_stock_return, nan_policy=nan_policy)
      if p > confidence_level:
        return False
      elif p <= confidence_level:
        return "normal"
    except ValueError as error:
      logging.debug(error)

  def getRegression(df: pandas.core.frame.DataFrame, period: int, rf: float, confidence_level: float) -> pandas.core.frame.DataFrame:
    df_ny = filterDataBasedYear(df, period).set_index("Date").sub(rf/100)
    df_ny = df_ny.apply(lambda x: calc_beta(x.values.tolist(), df_ny["^KLSE"].values.tolist(), confidence_level=confidence_level), axis=0)
    df_ny = df_ny.transpose().reset_index()
    df_ny.columns = ["STOCK CODE",f"BETA_{period}Y", f"INTERCEPT_{period}Y", f"R-SQUARED_{period}Y", f"P-VALUE_{period}Y", f"BETA STANDARD ERROR_{period}Y", f"NORMALITY TEST_{period}Y"] 
    df_ny["STOCK CODE"] = df_ny["STOCK CODE"].replace({"[.]KL": ""}, regex=True)
    return df_ny

  regression_df = getRegression(total_stock_return_df, period=period, rf=rf, confidence_level=confidence_level)
  # st.dataframe(regression_df.sort_values(f"INTERCEPT_{period}Y", ascending=False))

  #### -- Calculate Annualized Return and Standard Devation

  def getAnnualizedReturn(df, interval:str, type:str="geometric", skipna:bool=False):
    """Params:
    interval : str
      Valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo
    """
    if type == "arithmetic":
      df= df.mean(skipna=skipna)
    elif type == "geometric":
      if skipna:
        df = df.add(1).apply(lambda x: scipy.stats.gmean(x.dropna(inplace=False)), axis=0).sub(1)
      else:
        df = df.add(1).apply(scipy.stats.gmean).sub(1)
    annualized_return_dict = {"1d": 252,"1wk":52, "1mo":12, "3mo":4}
    annualized_return = df.multiply(annualized_return_dict[interval])
    return annualized_return

  def getAnnualizedStdDeviation(df, interval:str = interval, skipna=skipna):
    """Params:
    interval : str
      Valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo
    """
    df = df.std(skipna=skipna)
    annualized_std_dict = {"1d": 252,"1wk":52, "1mo":12, "3mo":4}
    annualized_std = df.multiply(annualized_std_dict[interval])
    return annualized_std

  # Step 6: Upload 2Y-Beta, 5Y-Beta and standard deviation of equity to Google Spreadsheet: sheet "Calculated" 
  x_list = []
  descriptive_df = pandas.DataFrame()

  descriptive_df[f"standard_deviation_of_equity_{period}Y"] = getAnnualizedStdDeviation(filterDataBasedYear(total_stock_return_df, period =2).set_index("Date"), interval=interval, skipna=skipna)
  descriptive_df[f"annualized_return_of_equity_{period}Y"] = getAnnualizedReturn(filterDataBasedYear(total_stock_return_df, period=2).set_index("Date"), interval=interval, skipna=skipna)
  descriptive_df = descriptive_df.reset_index()
  descriptive_df = descriptive_df.rename(columns={"index":"STOCK CODE"})
  descriptive_df["STOCK CODE"] = descriptive_df["STOCK CODE"].replace("[.]KL", "", regex=True)

  # descriptive_df.sort_values(f"annualized_return_of_equity_{period}Y", ascending=False)

  ## Merge All DataFrame
  # merge dataframes of `clean_df_stock_list`, `regression_df`, `descriptive_df`

  from functools import reduce

  main_dataframe = [clean_df_stock_list, regression_df, descriptive_df]

  merged_df = reduce(lambda left, right: pandas.merge(left, right, on="STOCK CODE", how ="left"), main_dataframe)

  st.markdown("## Bursa stock performance")
  st.dataframe(merged_df.sort_values(f"INTERCEPT_{period}Y", ascending=False))
  merged_df.to_csv("./bursa_companies.csv", columns= merged_df.columns)

  """## Aggregate Data"""

  sector_overview_df = merged_df.groupby("SECTOR").agg({f"BETA_{period}Y": "mean",
                                      f"INTERCEPT_{period}Y": "mean",
                                      f"annualized_return_of_equity_{period}Y": "mean", 
                                      f"standard_deviation_of_equity_{period}Y": "mean"
                                      }).dropna().sort_values(f"INTERCEPT_{period}Y", ascending=False)
  st.markdown("## Sector Overview Dataframe")
  st.dataframe(sector_overview_df)
  sector_overview_df.to_csv("./sector_overview.csv", columns= sector_overview_df.columns)

  sub_sector_overview_df = merged_df.groupby("SUBSECTOR").agg({f"BETA_{period}Y": "mean",
                                      f"INTERCEPT_{period}Y": "mean",
                                      f"annualized_return_of_equity_{period}Y": "mean", 
                                      f"standard_deviation_of_equity_{period}Y": "mean"
                                      }).dropna().sort_values(f"INTERCEPT_{period}Y", ascending=False)
  st.markdown("## Sub-Sector Overview Dataframe")
  st.dataframe(sub_sector_overview_df)
  sub_sector_overview_df.to_csv("./subsector_overview.csv", columns=sub_sector_overview_df.columns)
  
  # update last updated date and time
  
  
  with open("./data/last_updated.txt", "a") as file:
    file.write(datetime.datetime.now().strftime("%d-%m-%Y"))
    